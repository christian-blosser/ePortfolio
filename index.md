# Professional ePortfolio
### Introduction - A collection and showcase of works completed by Christian Blosser
The journey through the Computer Science (CS) program has assisted with my own self-improvement.  I cannot claim to know everything there is to know, but I can claim that I will always complete a job properly to its entirety.  This ePortfolio has provided the opportunity to showcase a few strengths I have practiced and developed.  However, it cannot provide everything I have learned.  Throughout my journey I was privileged to learn and develop in many areas of CS that I cannot showcase within my portfolio:
-	Team collaboration within multiple environments.  The CS program has given me a firsthand experience with using repositories, waterfall and agile development cycles, code and peer reviewing, and collaborative critical thinking while engaging with a team.
-	Professionally communicating to stakeholders.  Using data mining, statistics, survey reports, financial reports, and other official documents, I assessed the Bubba Gump Shrimp Company for profit loss.  Utilizing statistical software JMP, I assessed correlations, developed numerous types of graphs, accounted for outlying causes, and identified corrective actions.
-	Data structures and algorithms.  I developed an understanding of data structures and algorithms in the early periods of the CS program and have been building on these topics ever since.  Using programming tools such as arrays, linked lists, search trees, vectors, or hash tables can increase efficiency and scalability of any program.
-	Software engineering, databasing, and security.  As the world becomes more connected and develops more of an online presence, the need for these three skills come in higher demand.  Throughout the entire CS program, software engineering was a large part of the development.  Using multiple languages, developing complex functions, following best practices, programming for scalability and reuse, and quality assurance testing, the skills developed will prove to be priceless.  In addition, securely coding a program consists of having no errors or warnings, algorithmically airtight, proper use of input validation, and eliminating any potential for unwanted intrusion.
## &emsp;
Contained in this portfolio is a collection of works that I have personally selected to showcase some of my abilities.  I was able to demonstrate my developments in data structures and algorithms, software engineering and design, program development, databasing, and security.  These separate projects fit together to provide a glimpse into the capabilities of what I can do.
The three projects below are as follows:
-	A recreation from C++ to Java
-	A recursive implementation of the merge sort algorithm.
-	An implementation of advanced MySQL concepts and queries.



## Informal Code Review - [Youtube Video](https://youtu.be/WIEzl36tGwA)
Code reviews can be characterized as a list of items to go over and ensure criteria is met.  This can be done by you, a developer, or one of your peers.  The items usually attempt to identify obvious errors, obvious logical errors, proper documentation, proper testing, format and styling abnormalities, proper functionality, and overall completeness (Radigan).  Essentially, a code review is an end to end review of the completed work done within a timeframe or as a complete product.  Specifically, this review encapsulates the three major projects for this course.
### &emsp;


# Enhancements
## Overview
Below are the enhancements I have made.  All works below are provided by Southern New Hampshire University (SNHU), recreations of works provided by SNHU, or are of my own implementation.
### &nbsp;


## Enhancement One - Software Design and Engineering
Link to [BitBucket Repository](https://bitbucket.org/Christian_Blosser/finalsourcecatonerevised/src/master/FinalProjectEnhancements/) for enhancement source code.  
Link to [BitBucket Repository](https://bitbucket.org/Christian_Blosser/finalsourcecatone/src/master/CS%20405%20Final%20Project/)for original source code.  

My first enhancement was to a project I completed in CS 405: Secure Coding.  In this project, we were assigned with finding security vulnerabilities and creating solutions to those findings.  Some of those findings were of original user error while others were created within the program in order to provide examples of different security issues.  The program was written by author, Curtis, on November 5, 2017 in the C++ language.  Overall, this program was a little difficult to interpret, as it was nearly comment free and I do not have extended experience in C++.  For this program’s enhancement, I chose to convert from C++ to Java.  This would entail converting every file and function into classes and methods for Java.

### Selection Process
Making a final selection on a project was a daunting task, however, as this will be used as a professional portfolio to showcase to possible employers, I needed to select a project that would stand out from others regarding both talent and reasoning.  There are a couple of different reasons why I chose this project over all the rest:
- Versatility.  Being able to understand, interpret, and manipulate multiple computer languages is a valuable skillset to have.  Continuing programming in C++ would be excellent to make improvements but translating from language to language is an enormous skill to have in a world where there are hundreds of languages used every day.  Knowing more than one language will assist in problem solving, syntax dilemma's, and increase your chance of success with trying a different language (Hill, 2017).  In a cybersecurity career threats will not always appear in my desired language, so at the very least, versatility is being well prepared.
- Personal gain.  As mentioned, I know C++ language, but have not used it much.  As this project is written in C++, it was experience building for me to interpret C++ and translate it into a language that I know better.  Also, familiarity with Java made it easier for me to deal with some misinterpretations or lack of understanding in general.  Being able to grasp the concept of what was happening in C++ allowed me to implement my own design during the translation process.
- The source.  As this project had intentional and nonintentional errors, the learning experience with this program has been continuous.  As I was translating, I was finding errors that I did not catch in my code review.  This project has offered me deeper insight on how to catch errors and vulnerabilities, giving me experience and teaching me wisdom.
- Critical thinking and decision making.  Critically thinkng is being able to define a problem, devise questions based on the problem, and rationally and reasonably develop a solution to the problem (_Critical Thinking_).There are files that were missing from this program and places where these files would have made the program sound and understandable.  Unfortunately, I was not provided those files from the source and had to make do with what I knew and what I did have.  This allowed me to analyze the program from different angles and decide what I could do in the different situations.  For example, a '.dat' file was referenced a number of times within the program, but I was not provided with the '.dat' file.  This made it a little more difficult, but I made the decision to work with multiple CSV files in order to implement a correct solution.
- Never-before-seen implementations.  Most of this program made sense, while the rest was puzzling.  I have never dealt with usernames and passwords before, nor have I ever written a CSV file from code.  These translated implementations were a great challenge for me and utilized or expanded my knowledge base for this milestone.  These areas are currently functional, but I believe they still need further modifications for exceptionality.  In the words of Saheb Motiani, "In one line, the best way to learn something new is to apply it."
- Lastly, the challenge.  Converting from one language to another is never a line by line translation.  Throughout this conversion, I have found myself with more lines of code in Java than the C++ counterpart, or vice versa.  Each language has their own flow, their own feel, and their own techniques to use.  C is the parent language to both C++ and Java, however, they each have a completely different style.  C++ is more closely related to C in that it could be used as a mid-level programming language while Java is at the top end and handles almost all the memory overhead itself.  The challenge of this conversion is rather exciting and fun to me. <br />

## &emsp;
### Reflection on Enhancement One
As I began, I followed the flow of the program starting with the main function.  From here, there were calls made to other files.  Development was linear in respect to algorithmic runtime.  My process was simple regarding the steps in translation.  I would first assess the function and grasp the full concept or partial concept of what it was trying to accomplish.  Then, I would assess how it interacted with other functions such as variables passed or if passing variables would make it more efficient.  Next, I began the translation process trying to maintain line by line transfer.  Lastly, once the function was written, I would assess the need for improvement and implement it.  In short, I translated and improved the original source code. <br />
<br >The process was not all that simple, however.  I learned that reading files and manipulating file data seems to be simpler in C++ than in Java.  Most of my program was lengthened due to implementation of FileWriter, Scanner, and File manipulations in attempt to recreate the original functionality.  I also expanded my knowledge of C++ and Java programming.  Being naïve, I thought I had a good grasp of Java programming.  I stand corrected after undergoing countless hours of troubleshooting, revising, and researching due to improper implementation.  In one case, I forgot to close a Scanner object that had taken almost two hours of time to find and create. <br />
<br >I faced a few challenges along the way.  In addition to the things I have learned due to the challenges, I have also learned how to better manage time with the unknown.  As I mentioned earlier, I had worked on this capstone project for 31 hours this week in addition to maintaining my adult responsibilities such as working 40 hours, grocery shopping, feeding myself, and managing to maintain a healthy work-life balance. <br />

<br ><br />

## Enhancement Two - Algorithms and Data Structures
Link to [BitBucket Repository](https://bitbucket.org/Christian_Blosser/recursivemergesort/src/master/FinalProjectSorting/) for original source code.

My second enhancement was to create a project based on my learning experience in CS 260: Data Structures and Algorithms.  In this course, I gained the basic concepts of different data structures that can be used and implemented within programs.  For that final project, I compiled a detailed list of a few different data structures such as linked lists, vectors, and hash tables.  For my second enhancement, I decided to utilize other information from that course and implement and develop a known algorithm.  For this I chose to implement the recursive merge sort algorithm.  I developed a Java program to complete three main tasks:
1. Create files with random numbers inside with the amount of random numbers being at set intervals of 10,000, 100,000, and 1,000,000 random numbers per file.
2. Implement the recursive merge sort algorithm with precise accuracy.  The merge sort algorithm is comprised of two methods/functions: mergesort and merge.
3. Print the sorted numbers from the random files and time results.  Each random file created is sorted and then printed to a new file to compare.  Also, the amount of time it takes to sort each file is stored and printed to its own text file.

## &emsp;
### Selection Process
Choosing this enhancement did not come easy.  When I first started to formulate ideas for my capstone project, I originally wanted to add to my first enhancement.  However, I could not develop an idea that I felt would satisfy the category of Algorithms and Data Structures.  As I thought and reviewed my final projects and code associated, I started to think of algorithms.  This led me to what I have implemented.  This implementation was chosen for a couple different reasons to include:
- Development process.  This implementation of merge sort is of my own creation, and it was not provided through a final project.  Therefore, I had to develop it on my own with nothing more than a few descriptions of how it is to be implemented.  This showcases a more than basic understanding of how to develop a program, regardless of the size of the program.
- Diversification.  This was my first attempt at implementing a known algorithm, so I consider this to be a benefit in my own ways in terms of practice.  In addition, this shows that I am adaptive and diverse in development.  "Developing an algorithm allows and even forces examination of the solution process in a rational manner" (Upton).  Sorting data is an implementation that will forever be needed and trying methods of sorting that are not included with language API’s is great practice.  Grasping even a basic understanding of how (for instance) Java’s array utility, Arrays.sort(), method works is one step closer to mastering computer science, or even a language.
- Efficiency and Intermediate understanding.  Programming recursive functions/methods shows an intermediate understand of how to develop code.  It is a concept that can be difficult to understand and grasp and is more advanced than the basic teachings of loops.  Recursion is also known to be a more efficient implementation of a loop.  Even with technologies developing in accordance to Moore’s Law, efficiency is still of utmost importance when developing a program.  Always be as efficient as possible when implementing an algorithm.
- Lastly, the challenge.  When I first entered this field, implementing the fundamental “Hello, world!” was challenging for me. . . even with Eclipse providing it!  Now, implementing the fundamental program, I have learned, is basically how you start every program.  That said, I still do not know everything.  This was a new and exciting process that challenged through almost every step of the development process.  Practice makes perfect.  

## &emsp;
### Reflection on Enhancement Two
As I began the process of development, I scoured for a detailed understanding of merge sort.  Before my code review, I had a basic understanding of both recursion and merge sort.  From there, I developed pseudocode for my merge sort implementation.  I had not begun development until late into week 3.  I was fortunate in that my previous enhancement gave me practice on how to read and write to files from Java, and this was a huge help to be able to manipulate the files to sort.  My development process was as follows:
1. Plan.  I had planned my program and conceptualized everything that it would need to be functional for what I needed it for.  I had thought of most of what I would need, but I did have to develop a way to manage the runtimes (simple array fix).
2. Implement.  I started with merge sort itself first and followed my pseudocode almost line-for-line.  While I was implementing, I had tested the sorting on a small array of 100 random numbers.  Next, I began to develop the file creation and printing random numbers to the files.  Lastly, I brought everything together by creating random files, sorting those files, and printing them to a separate file.
3. Testing and review.  Testing was a rather white-box execution process where I did not automate tests as the program runs linearly with no input from the user.  For the reviewing of this program, I ensured proper header comments, proper formatting of code, and proper comments used to clarify each step of each process.  
## &emsp;
What I have learned through this process has been priceless.  I have learned how to implement an algorithm from pseudocode to final production, managing my time better with the unknown, a better understanding of Java file CRUD operations, recursion, and even sorting in general.  This particular enhancement has been absolutely priceless for me.  The knowledge that I have learned, or have started to learn, will allow me to advance my understand in program development, program efficiency, and algorithms.

## Enhancement Three - Databases
Link to [BitBucket Repository](https://bitbucket.org/Christian_Blosser/finalsourcecatthree/src/master/FinalSourceCatThree/PortfolioProjectThree.sql) for original source code.  
Link to [Result Excel File](https://1drv.ms/x/s!AiPPn2_yADjBiEpTmHUcWldcDcvh?e=HqYRlV).  

My third enhancement was to further my final project from DAD 220: Introduction to SQL.  In this course I learned to implement basic CRUD operations to manipulate and query an SQL database.  For my third enhancement, I decided to implement a few advanced MySQL concepts such as triggers, views, indexing, and full-text searching.  To execute these tasks, I needed to create a new schema/database, implement the triggers, populate the database, implement the views, and then use a full-text query.  Using a simple text-editor program, I can write my SQL code.  Additionally, with use of an online compiler, I can compile my SQL file with the latest version of MySQL.

### Selection Process
When I was first aware of the guidelines of my capstone course, I had a basic idea of what I was going to do for my first and second enhancement.  I was very uncertain what I was going to be doing for my third enhancement, however.  I began scouring for ideas from previous courses, the internet, and my professor until I had come across an article online that posed advanced MySQL concepts.  Once I found this article, I was able to make my decision.  While I was in search for the answer I had found, I kept in mind a few things that I would need to showcase under the database category, in addition to why I ultimately chose to enhance this project:
- Personal gain.  Databases have been briefly touched at SNHU, but I knew that they are heavily used in the real world by large companies such as Auto Trader, Ebay, and Amazon (Unknown).  For this reason, I needed to familiarize myself with concepts of databases and gain the knowledge necessary to tackle any database, regardless of the language; databases can be written and maintained in any one language, but a concept is universal.  Through this project, I was able to grasp, comprehend, and implement different concepts used in databasing.  The experience and knowledge gained is priceless.
- Content creation.  DAD 220 was simply an introduction to SQL.  During this course we learned and performed basic CURD operations to very small databases.  I wanted to expand on the knowledge I had.  I view SQL as a user-friendly language, making it an excellent place to expand upon to grasp concepts and implement more advanced features to databases.  I utilized what I had learned in the course and applied it to create my own sample database to showcase my skills.
- Research and dedication.  Developing the idea of how to create my third enhancement, I found myself doing more research than development.  SQL is easy to use. . . once you know how to use it.  I began researching the MySQL API to find concepts that were more advanced than what an introductory course could teach.  This took a lot of internet hours and ultimately time sifting through the language API to develop concepts.
- Useful (to me at least).  What I decided to implement was based on what I had found useful, but remaining advanced.  The concepts of triggers can only help a database, views are very useful for frequently queried items, indexes increase the efficiency of a query, and full-text querying is useful when a lengthy descriptor is used (or similar).  There were concepts that were much more advanced, but they did not seem practical for this use.  My idea of this may change once I am employed and could view these, however.
- As always, the challenge.  To complete this enhancement, I needed to do a significant amount of research and discover new topics that were not addressed during the course.  I found this process mildly difficult as I did not know what I was looking for exactly.  Eventually, with a nudge from the MySQL API webpage, I quickly turned my attention to the MySQL language itself to discover functions that I have not seen before.

## &emsp;
### Reflection on Enhancement Three
I began developing this enhancement from an idea.  I knew what I needed to do to set up a database and get the basics, so I created a database and populated it with rows of data.  This was intended as practice.  I then began to develop ideas on how I would develop triggers and how I could use them to my advantage and how they could be applied to real world applications.  Triggers are excellent data integrity verifiers because triggers can be executed before or after an insert, update, or delete.  For example, a trigger can be used to verify a positive number such as age where it can never be negative.  From there, I began to develop more ideas using the same basis for though to implement the views. <br />
<br >This enhancement has introduced brand new databasing concepts to my range of skillsets.  Before this project, I was able to perform basic SQL CRUD operations.  I am now able to create data integrity checking, frequently queried views, increase the speed at which a query runs, and search entries by full text.  All these enhancements have been a positive enforcement and addition to my databasing knowledge.  I have also learned another technique towards researching and problem solving.  Typically, I would result to a google search for comparable issues or concepts with code in general.  I have learned, rather, to start with language API itself and progress from there.  I had no clue what to search but using the built in ‘HELP’ function directed me towards what I needed to know. <br />
<br >I faced a few challenges while developing my enhancement.  My most frustrating challenge was the loss of my work.  Due to a time limit for courses to be open using Codio IDE (a third-party platform used by SNHU for STEM courses), code that I had developed was lost due to archiving.  I had to start anew and rewrite what I had already done.  My second challenge was conceptualizing SQL syntax for certain statements, namely the trigger implementations.  I had not worked with SQL in about two years, so I immediately had to brush up on the terminology and syntax to be able to complete some of the code. <br />

## References
1. Critical Thinking. (2016, August 12). Retrieved October 1, 2020, from https://www.jennysgrandchild.com/critical-thinking/
2. Hill January 29, J. (2017, January 29). The Benefits of Learning Multiple Programming Languages - Digital product development agency: Big Nerd Ranch. Retrieved October 18, 2020, from https://www.bignerdranch.com/blog/the-benefits-of-learning-multiple-programming-languages/
3. Motiani, S. (2014, January 31). What is the Most Efficient Way to Learn a New Programming Language. Retrieved October 1, 2020, from https://www.quora.com/What-is-the-most-efficient-way-to-learn-a-new-programming-language
4. Radigan, D. (n.d.). Why code reviews matter (and actually save time!). Retrieved October 18, 2020, from https://www.atlassian.com/agile/software-development/code-reviews
5. Unknown. (2012, October 7). 10 interesting facts about SQL for beginners. Retrieved October 15, 2020, from http://ajksqlteacher.blogspot.com/2012/10/10-interesting-facts-about-sql-for.html
6.Upton, D. E. (n.d.). ALGORITHMS. Retrieved October 2, 2020, from https://www.referenceforbusiness.com/encyclopedia/A-Ar/Algorithms.html
